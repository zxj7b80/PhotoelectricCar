###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        30/Dec/2015  17:14:56
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\C\Component_C\i2c.c
#    Command line =  
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\C\Component_C\i2c.c"
#        -D IAR -D TWR_K60N512 -lCN
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\bin\Flash\List\"
#        -lB
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\bin\Flash\List\"
#        -o
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\bin\Flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\MyProgramFiles\IAR
#        7.10.3\arm\INC\c\DLib_Config_Normal.h" -I
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\H\"
#        -I
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\H\Component_H\"
#        -I
#        "G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\H\Frame_H\"
#        -Ol --use_c++_inline
#    List file    =  
#        G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\bin\Flash\List\i2c.lst
#    Object file  =  
#        G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\bin\Flash\Obj\i2c.o
#
###############################################################################

G:\FREESCALE智能车竞赛\freescale(九)\程序\总决赛比赛程序21.22.23\2014.08.22\src\Sources\C\Component_C\i2c.c
      1          //============================================================================
      2          // 文件名称：hw_i2c.h                                                          
      3          // 功能概要：uart构件头文件
      4          // 版权所有: 苏州大学飞思卡尔嵌入式中心(sumcu.suda.edu.cn)
      5          // 版本更新:    时间                         版本                     作者                          修改
      6          //           2011-11-17     V1.0       stone    编写了K60的i2c驱动
      7          //============================================================================
      8          
      9          
     10          #ifndef __I2C_H__
     11          #define __I2C_H__
     12          	
     13          #include "common.h"
     14          #include "i2c.h"
     15          
     16          //============================================================================
     17          //函数名称：hw_i2c_init                                                        
     18          //功能概要：初始化IICX模块。                                                
     19          //参数说明：num:模块号                                                         
     20          //函数返回：无                                                                  
     21          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     22          void hw_i2c_init(I2C_MemMapPtr num)
     23          {
     24          	
     25          	if(num == I2C0)
   \                     hw_i2c_init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable1  ;; 0x40066000
   \   00000002   0x4288             CMP      R0,R1
   \   00000004   0xD114             BNE.N    ??hw_i2c_init_0
     26          	{
     27          		//打开I2C0模块时钟
     28          		SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK; 
   \   00000006   0x....             LDR.N    R0,??DataTable1_1  ;; 0x40048034
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000000E   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40048034
   \   00000010   0x6008             STR      R0,[R1, #+0]
     29          		//配置引脚复用为I2C0功能
     30          		//I2C0 SCL使用PTD8
     31          		//I2C0 SDA使用PTD9
     32          		PORTD_PCR9 = PORT_PCR_MUX(2);
   \   00000012   0xF44F 0x7000      MOV      R0,#+512
   \   00000016   0x....             LDR.N    R1,??DataTable1_2  ;; 0x4004c024
   \   00000018   0x6008             STR      R0,[R1, #+0]
     33          		PORTD_PCR8 = PORT_PCR_MUX(2);
   \   0000001A   0xF44F 0x7000      MOV      R0,#+512
   \   0000001E   0x....             LDR.N    R1,??DataTable1_3  ;; 0x4004c020
   \   00000020   0x6008             STR      R0,[R1, #+0]
     34          		//设置 MULT 和 ICR   
     35          		//芯片手册推荐设置100K以减小MCU负载
     36          		//k60的MCU总线频率为48M，在总线上分频
     37          		I2C0_F  = 0x65;   
   \   00000022   0x2065             MOVS     R0,#+101
   \   00000024   0x....             LDR.N    R1,??DataTable1_4  ;; 0x40066001
   \   00000026   0x7008             STRB     R0,[R1, #+0]
     38          		//使能I2C0，不发送应答信号
     39          		I2C0_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;      
   \   00000028   0x2088             MOVS     R0,#+136
   \   0000002A   0x....             LDR.N    R1,??DataTable1_5  ;; 0x40066002
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   \   0000002E   0xE013             B.N      ??hw_i2c_init_1
     40          	}
     41          	else
     42          	{
     43          		//打开I2C1模块时钟
     44          		SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK; 
   \                     ??hw_i2c_init_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable1_1  ;; 0x40048034
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000038   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40048034
   \   0000003A   0x6008             STR      R0,[R1, #+0]
     45          		//配置引脚复用为I2C1功能
     46          		//I2C1 SCL使用PTC10
     47          		//I2C1 SDA使用PTC11
     48          		PORTC_PCR10 = PORT_PCR_MUX(2);
   \   0000003C   0xF44F 0x7000      MOV      R0,#+512
   \   00000040   0x....             LDR.N    R1,??DataTable1_6  ;; 0x4004b028
   \   00000042   0x6008             STR      R0,[R1, #+0]
     49          		PORTC_PCR11 = PORT_PCR_MUX(2);
   \   00000044   0xF44F 0x7000      MOV      R0,#+512
   \   00000048   0x....             LDR.N    R1,??DataTable1_7  ;; 0x4004b02c
   \   0000004A   0x6008             STR      R0,[R1, #+0]
     50          		//设置 MULT 和 ICR   
     51          		//芯片手册推荐设置100K以减小MCU负载
     52          		//k60的MCU总线频率为48M，在总线上分频
     53          		I2C1_F  = 0x65;   
   \   0000004C   0x2065             MOVS     R0,#+101
   \   0000004E   0x....             LDR.N    R1,??DataTable1_8  ;; 0x40067001
   \   00000050   0x7008             STRB     R0,[R1, #+0]
     54          		//使能I2C1，不发送应答信号
     55          		I2C1_C1 = I2C_C1_IICEN_MASK | I2C_C1_TXAK_MASK;      
   \   00000052   0x2088             MOVS     R0,#+136
   \   00000054   0x....             LDR.N    R1,??DataTable1_9  ;; 0x40067002
   \   00000056   0x7008             STRB     R0,[R1, #+0]
     56          	}
     57          }
   \                     ??hw_i2c_init_1: (+1)
   \   00000058   0x4770             BX       LR               ;; return
     58          
     59          //============================================================================
     60          //函数名称：hw_send_signal                                                        
     61          //功能概要：根据需要产生开始或停止信号   。                                                
     62          //参数说明：         num:模块号       
     63          //          Signal: 'S'(Start),产生开始信号      'O'(Over),  产生停止信号               
     64          //函数返回：无                                                                  
     65          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     66          void hw_send_signal(uint8 Signal,I2C_MemMapPtr num)
     67          {
     68          	
     69          	if(num == I2C0)//模块0
   \                     hw_send_signal: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable1  ;; 0x40066000
   \   00000002   0x4291             CMP      R1,R2
   \   00000004   0xD113             BNE.N    ??hw_send_signal_0
     70          	{
     71          		if (Signal == 'S')    
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2853             CMP      R0,#+83
   \   0000000A   0xD106             BNE.N    ??hw_send_signal_1
     72          		{
     73          		  i2c0_Start(); //主机模式选择位MST由0变为1,可以产生开始信号  
   \   0000000C   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40066002
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000014   0x....             LDR.N    R1,??DataTable1_5  ;; 0x40066002
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   \   00000018   0xE01F             B.N      ??hw_send_signal_2
     74          		}
     75          		else if (Signal == 'O')
   \                     ??hw_send_signal_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x284F             CMP      R0,#+79
   \   0000001E   0xD11C             BNE.N    ??hw_send_signal_2
     76          		{
     77          		  i2c0_Stop();//主机模式选择位MST由1变为0,可以产生停止信号
   \   00000020   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40066002
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000028   0x....             LDR.N    R1,??DataTable1_5  ;; 0x40066002
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   \   0000002C   0xE015             B.N      ??hw_send_signal_2
     78          		}
     79          	}
     80          	else if(num == I2C1)//模块1
   \                     ??hw_send_signal_0: (+1)
   \   0000002E   0x....             LDR.N    R2,??DataTable1_10  ;; 0x40067000
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xD112             BNE.N    ??hw_send_signal_2
     81          	{
     82          		if (Signal == 'S')    
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2853             CMP      R0,#+83
   \   00000038   0xD106             BNE.N    ??hw_send_signal_3
     83          		{
     84          		  i2c1_Start(); //主机模式选择位MST由0变为1,可以产生开始信号  
   \   0000003A   0x....             LDR.N    R0,??DataTable1_9  ;; 0x40067002
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000042   0x....             LDR.N    R1,??DataTable1_9  ;; 0x40067002
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   \   00000046   0xE008             B.N      ??hw_send_signal_2
     85          		}
     86          		else if (Signal == 'O')
   \                     ??hw_send_signal_3: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x284F             CMP      R0,#+79
   \   0000004C   0xD105             BNE.N    ??hw_send_signal_2
     87          		{
     88          		  i2c1_Stop();//主机模式选择位MST由1变为0,可以产生停止信号
   \   0000004E   0x....             LDR.N    R0,??DataTable1_9  ;; 0x40067002
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000056   0x....             LDR.N    R1,??DataTable1_9  ;; 0x40067002
   \   00000058   0x7008             STRB     R0,[R1, #+0]
     89          		}
     90          	}
     91          	        
     92                                                        
     93                
     94          }
   \                     ??hw_send_signal_2: (+1)
   \   0000005A   0x4770             BX       LR               ;; return
     95          
     96          
     97          
     98          //============================================================================
     99          //函数名称：hw_wait                                                        
    100          //功能概要： 在时限内,循环检测接收应答标志位,或传送完成标志位,判断MCU         
    101          //          是否接收到应答信号或一个字节是否已在总线上传送完毕                                            
    102          //参数说明：         num:模块号       
    103          //               x:x = 'A'(Ack),等待应答;x = 'T'(Transmission),等待一个字节        
    104          //                 数据传输完成                   
    105          //函数返回：0:收到应答信号或一个字节传送完毕;
    106          //         1:未收到应答信号或一个 字节没传送完                                                                                                                            
    107          //============================================================================
    108          

   \                                 In section .text, align 2, keep-with-next
    109          uint8 hw_wait(uint8 x,I2C_MemMapPtr num)
    110          {
   \                     hw_wait: (+1)
   \   00000000   0xB410             PUSH     {R4}
    111              uint16 ErrTime, i;
    112              ErrTime = 255*10;            //定义查询超时时限
   \   00000002   0xF640 0x12F6      MOVW     R2,#+2550
    113          
    114          	for (i = 0;i < ErrTime;i++)
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xE000             B.N      ??hw_wait_0
   \                     ??hw_wait_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??hw_wait_0: (+1)
   \   0000000C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD213             BCS.N    ??hw_wait_2
    115          	{
    116          		if (x == 'A')           //等待应答信号
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2841             CMP      R0,#+65
   \   00000018   0xD104             BNE.N    ??hw_wait_3
    117          		{
    118          			  if(( I2C_S_REG(num)  & I2C_S_RXAK_MASK)==0)
   \   0000001A   0x78CC             LDRB     R4,[R1, #+3]
   \   0000001C   0x07E4             LSLS     R4,R4,#+31
   \   0000001E   0xD4F4             BMI.N    ??hw_wait_1
    119          				 return 0;      //传送完一个字节后,收到了从机的应答信号               
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE011             B.N      ??hw_wait_4
    120          		}
    121          		else if (x == 'T')      //等待传送完成一个字节信号
   \                     ??hw_wait_3: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2854             CMP      R0,#+84
   \   00000028   0xD1EF             BNE.N    ??hw_wait_1
    122          		{
    123          			if ((I2C_S_REG(num) & I2C_S_IICIF_MASK) != 0)    
   \   0000002A   0x78CC             LDRB     R4,[R1, #+3]
   \   0000002C   0x07A4             LSLS     R4,R4,#+30
   \   0000002E   0xD5EC             BPL.N    ??hw_wait_1
    124          			{
    125          				(I2C_S_REG(num) |=(0 | I2C_S_IICIF_MASK));  //清IICIF标志位
   \   00000030   0x78C8             LDRB     R0,[R1, #+3]
   \   00000032   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000036   0x70C8             STRB     R0,[R1, #+3]
    126          				return 0;       //成功发送完一个字节
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE005             B.N      ??hw_wait_4
    127          			}       
    128          		}
    129          	}
    130          	if (i >= ErrTime)
   \                     ??hw_wait_2: (+1)
   \   0000003C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000040   0x4293             CMP      R3,R2
   \   00000042   0xD301             BCC.N    ??hw_wait_5
    131          		return 1;               //超时,没有收到应答信号或发送完一个字节   	
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE7FF             B.N      ??hw_wait_4
    132          }
   \                     ??hw_wait_5: (+1)
   \                     ??hw_wait_4: (+1)
   \   00000048   0xBC10             POP      {R4}
   \   0000004A   0x4770             BX       LR               ;; return
    133          
    134          
    135          //============================================================================
    136          //函数名称：hw_iic_read1                                                        
    137          //功能概要：从从机读1个字节数据                                            
    138          //参数说明：  num:模块号       
    139          //          DeviceAddr:设备地址    
    140          //          AccessAddr:访问地址
    141          //          Data:带回收到的一个字节数据  
    142          //函数返回：为0,成功读一个字节;为1,读一个字节失败  
    143          //函数说明: 内部调用 hw_send_signal,hw_wait  
    144          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    145          uint8 hw_iic_read1(I2C_MemMapPtr num,uint8 DeviceAddr, uint8 AccessAddr, uint8 *Data)
    146          {      
   \                     hw_iic_read1: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
    147                
    148          	I2C_C1_REG(num)     |= 0x10;           //TX = 1,MCU设置为发送模式
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000010   0x70A0             STRB     R0,[R4, #+2]
    149          	hw_send_signal('S',num);               //发送开始信号 
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       hw_send_signal
    150          	I2C_D_REG(num)  = DeviceAddr & 0xfe;   //发送设备地址,并通知从机接收数据
   \   0000001A   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   0000001E   0x7120             STRB     R0,[R4, #+4]
    151          	 
    152          	if (hw_wait('T',num))                  //等待一个字节数据传送完成  
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x2054             MOVS     R0,#+84
   \   00000024   0x.... 0x....      BL       hw_wait
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??hw_iic_read1_0
    153          	{      
    154          
    155          		return 1;                         //没有传送成功,读一个字节失败   
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE044             B.N      ??hw_iic_read1_1
    156          	}
    157          	if (hw_wait('A',num))                 //等待从机应答信号 
   \                     ??hw_iic_read1_0: (+1)
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x2041             MOVS     R0,#+65
   \   00000034   0x.... 0x....      BL       hw_wait
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??hw_iic_read1_2
    158          	{
    159          
    160          		return 1;                         //没有等到应答信号,读一个字节失败 
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE03C             B.N      ??hw_iic_read1_1
    161          	}
    162          	I2C_D_REG(num)  = AccessAddr;        //发送访问地址    
   \                     ??hw_iic_read1_2: (+1)
   \   00000040   0x7127             STRB     R7,[R4, #+4]
    163          	if (hw_wait('T',num))                //等待一个字节数据传送完成 
   \   00000042   0x0021             MOVS     R1,R4
   \   00000044   0x2054             MOVS     R0,#+84
   \   00000046   0x.... 0x....      BL       hw_wait
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??hw_iic_read1_3
    164          	{
    165          	 
    166          		return 1;                        //没有传送成功,读一个字节失败
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE033             B.N      ??hw_iic_read1_1
    167          	}
    168          	if (hw_wait('A',num))                //等待从机应答信号   
   \                     ??hw_iic_read1_3: (+1)
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0x2041             MOVS     R0,#+65
   \   00000056   0x.... 0x....      BL       hw_wait
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??hw_iic_read1_4
    169          	{
    170          	  
    171          		return 1;                        //没有等到应答信号,读一个字节失败  
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE02B             B.N      ??hw_iic_read1_1
    172          	}
    173          	I2C_C1_REG(num) |= 0x04;//当MCU在主机模 式下，向该位写1将产生一个重新开始信号  
   \                     ??hw_iic_read1_4: (+1)
   \   00000062   0x78A0             LDRB     R0,[R4, #+2]
   \   00000064   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000068   0x70A0             STRB     R0,[R4, #+2]
    174          	I2C_D_REG(num) = DeviceAddr | 0x01; //通知从机改为发送数据    
   \   0000006A   0xF055 0x0001      ORRS     R0,R5,#0x1
   \   0000006E   0x7120             STRB     R0,[R4, #+4]
    175          	if (hw_wait('T',num))               //等待一个字节数据传送完成  
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x2054             MOVS     R0,#+84
   \   00000074   0x.... 0x....      BL       hw_wait
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD001             BEQ.N    ??hw_iic_read1_5
    176          	{
    177          	 
    178          		return 1;                       //没有传送成功,读一个字节失败 
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE01C             B.N      ??hw_iic_read1_1
    179          	}
    180          	if (hw_wait('A',num))               //等待从机应答信号  
   \                     ??hw_iic_read1_5: (+1)
   \   00000080   0x0021             MOVS     R1,R4
   \   00000082   0x2041             MOVS     R0,#+65
   \   00000084   0x.... 0x....      BL       hw_wait
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??hw_iic_read1_6
    181          	{
    182          	 
    183          		return 1;                      //没有等到应答信号,读一个字节失败
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xE014             B.N      ??hw_iic_read1_1
    184          	}
    185          	I2C_C1_REG(num) &= 0xef;           //TX = 0,MCU设置为接收模式    
   \                     ??hw_iic_read1_6: (+1)
   \   00000090   0x78A0             LDRB     R0,[R4, #+2]
   \   00000092   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000096   0x70A0             STRB     R0,[R4, #+2]
    186          	*Data = I2C_D_REG(num);            //读出IIC1D,准备接收数据   
   \   00000098   0x7920             LDRB     R0,[R4, #+4]
   \   0000009A   0x7030             STRB     R0,[R6, #+0]
    187          	if (hw_wait('T',num))              //等待一个字节数据传送完成  
   \   0000009C   0x0021             MOVS     R1,R4
   \   0000009E   0x2054             MOVS     R0,#+84
   \   000000A0   0x.... 0x....      BL       hw_wait
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD001             BEQ.N    ??hw_iic_read1_7
    188          	{  
    189          	 
    190          		return 1;                      //没有传送成功,读一个字节失败  
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE006             B.N      ??hw_iic_read1_1
    191          	}
    192          	hw_send_signal('O',num);           //发送停止信号    
   \                     ??hw_iic_read1_7: (+1)
   \   000000AC   0x0021             MOVS     R1,R4
   \   000000AE   0x204F             MOVS     R0,#+79
   \   000000B0   0x.... 0x....      BL       hw_send_signal
    193          	*Data = I2C_D_REG(num);            //读出接收到的一个数据    
   \   000000B4   0x7920             LDRB     R0,[R4, #+4]
   \   000000B6   0x7030             STRB     R0,[R6, #+0]
    194          	
    195          	return 0;                          //正确接收到一个字节数据
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??hw_iic_read1_1: (+1)
   \   000000BA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    196          	
    197          }
    198          
    199          //============================================================================
    200          //函数名称：hw_iic_write1                                                        
    201          //功能概要：向从机写1个字节数据                                           
    202          //参数说明：  num:模块号       
    203          //          DeviceAddr:设备地址    
    204          //          AccessAddr:访问地址
    205          //          Data:要发给从机的1个字节数据  
    206          //函数返回：为0,成功写一个字节;为1,写一个字节失败 
    207          //函数说明: 内部调用 hw_send_signal,hw_wait  
    208          //============================================================================
    209          

   \                                 In section .text, align 2, keep-with-next
    210          uint8 hw_iic_write1(I2C_MemMapPtr num,uint8 DeviceAddr, uint8 AccessAddr, uint8 Data)
    211          {
   \                     hw_iic_write1: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    212          	I2C_C1_REG(num) |= 0x10;             //TX = 1,MCU设置为发送模式
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000010   0x70A0             STRB     R0,[R4, #+2]
    213              hw_send_signal('S',num);             //发送开始信号
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       hw_send_signal
    214              I2C_D_REG(num) = DeviceAddr & 0xfe;  //发送设备地址,并通知从机接收数据
   \   0000001A   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   0000001E   0x7120             STRB     R0,[R4, #+4]
    215              if (hw_wait('T',num))                //等待一个字节数据传送完成
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x2054             MOVS     R0,#+84
   \   00000024   0x.... 0x....      BL       hw_wait
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??hw_iic_write1_0
    216                  return 1;                        //没有传送成功,写一个字节失败
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE02E             B.N      ??hw_iic_write1_1
    217              if (hw_wait('A',num))               //等待从机应答信号
   \                     ??hw_iic_write1_0: (+1)
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x2041             MOVS     R0,#+65
   \   00000034   0x.... 0x....      BL       hw_wait
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??hw_iic_write1_2
    218                  return 1;                       //没有等到应答信号,写一个字节失败   
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE026             B.N      ??hw_iic_write1_1
    219              I2C_D_REG(num) = AccessAddr;         //发送访问地址
   \                     ??hw_iic_write1_2: (+1)
   \   00000040   0x7126             STRB     R6,[R4, #+4]
    220              if (hw_wait('T',num))               //等待一个字节数据传送完成
   \   00000042   0x0021             MOVS     R1,R4
   \   00000044   0x2054             MOVS     R0,#+84
   \   00000046   0x.... 0x....      BL       hw_wait
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??hw_iic_write1_3
    221                  return 1;                       //没有传送成功,写一个字节失败
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE01D             B.N      ??hw_iic_write1_1
    222              if (hw_wait('A',num))               //等待从机应答信号
   \                     ??hw_iic_write1_3: (+1)
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0x2041             MOVS     R0,#+65
   \   00000056   0x.... 0x....      BL       hw_wait
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??hw_iic_write1_4
    223                  return 1;                      //没有等到应答信号,写一个字节失败   
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE015             B.N      ??hw_iic_write1_1
    224              I2C_D_REG(num) = Data;             //写数据
   \                     ??hw_iic_write1_4: (+1)
   \   00000062   0x7127             STRB     R7,[R4, #+4]
    225              if (hw_wait('T',num))              //等待一个字节数据传送完成
   \   00000064   0x0021             MOVS     R1,R4
   \   00000066   0x2054             MOVS     R0,#+84
   \   00000068   0x.... 0x....      BL       hw_wait
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ.N    ??hw_iic_write1_5
    226                  return 1;                      //没有传送成功,写一个字节失败
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE00C             B.N      ??hw_iic_write1_1
    227              if (hw_wait('A',num))              //等待从机应答信号
   \                     ??hw_iic_write1_5: (+1)
   \   00000074   0x0021             MOVS     R1,R4
   \   00000076   0x2041             MOVS     R0,#+65
   \   00000078   0x.... 0x....      BL       hw_wait
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ.N    ??hw_iic_write1_6
    228                  return 1;                      //没有等到应答信号,写一个字节失败   
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE004             B.N      ??hw_iic_write1_1
    229              hw_send_signal('O',num);           //发送停止信号
   \                     ??hw_iic_write1_6: (+1)
   \   00000084   0x0021             MOVS     R1,R4
   \   00000086   0x204F             MOVS     R0,#+79
   \   00000088   0x.... 0x....      BL       hw_send_signal
    230              return 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \                     ??hw_iic_write1_1: (+1)
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    231          }
    232          
    233          
    234          //============================================================================
    235          //函数名称：hw_iic_readn                                                        
    236          //功能概要： 从从机读N个字节数据                                             
    237          //参数说明：  num:模块号       
    238          //          DeviceAddr:设备地址    
    239          //          AccessAddr:访问地址
    240          //          Data:读出数据的缓冲区
    241          //          N:从从机读的字节个数 
    242          //函数返回： 为0,成功读N个字节;为1,读N个字节失败  
    243          //函数说明: 内部调用hw_iic_read1  
    244          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    245          uint8 hw_iic_readn(I2C_MemMapPtr num,uint8 DeviceAddr, uint8 AccessAddr, uint8 Data[], uint8 N)
    246          {
   \                     hw_iic_readn: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    247              uint16 i, j;
    248              for (i = 0;i < N;i++)
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
   \   00000012   0xE001             B.N      ??hw_iic_readn_0
   \                     ??hw_iic_readn_1: (+1)
   \   00000014   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_iic_readn_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x4581             CMP      R9,R0
   \   00000024   0xD216             BCS.N    ??hw_iic_readn_2
    249              {
    250                  for(j = 0;j <15*40 ;j++); //最小延时(发送的每个字节之间要有时间间隔)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??hw_iic_readn_3
   \                     ??hw_iic_readn_4: (+1)
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??hw_iic_readn_3: (+1)
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0xF5B0 0x7F16      CMP      R0,#+600
   \   00000032   0xDBFA             BLT.N    ??hw_iic_readn_4
    251                  if (hw_iic_read1(num,DeviceAddr, AccessAddr + i, &Data[i]))  
   \   00000034   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   0xEB19 0x0308      ADDS     R3,R9,R8
   \   0000003C   0xEB19 0x0207      ADDS     R2,R9,R7
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0031             MOVS     R1,R6
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       hw_iic_read1
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD0E1             BEQ.N    ??hw_iic_readn_1
    252                      return 1;             //其中一个字节没有接收到,返回失败标志:1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE007             B.N      ??hw_iic_readn_5
    253              }
    254              if (i >= N)
   \                     ??hw_iic_readn_2: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x45A1             CMP      R9,R4
   \   0000005E   0xD301             BCC.N    ??hw_iic_readn_6
    255                  return 0;                 //成功接收N个数据,返回成功标志:0
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE7FF             B.N      ??hw_iic_readn_5
    256          }
   \                     ??hw_iic_readn_6: (+1)
   \                     ??hw_iic_readn_5: (+1)
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    257          
    258          
    259          //============================================================================
    260          //函数名称：hw_iic_writen                                                        
    261          //功能概要： 向从机写N个字节数据                                              
    262          //参数说明：  num:模块号       
    263          //          DeviceAddr:设备地址    
    264          //          AccessAddr:访问地址
    265          //          Data:要写入的数据  
    266          //          N:从从机读的字节个数 
    267          //函数返回： 为0,成功写N个字节;为1,写N个字节失败
    268          //函数说明: 内部调用hw_iic_write1   
    269          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    270          uint8 hw_iic_writen(I2C_MemMapPtr num,uint8 DeviceAddr, uint8 AccessAddr,uint8 Data[], uint8 N)
    271          {
   \                     hw_iic_writen: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    272              uint16 i, j;
    273              for (i = 0;i < N;i++)
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
   \   00000012   0xE001             B.N      ??hw_iic_writen_0
   \                     ??hw_iic_writen_1: (+1)
   \   00000014   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_iic_writen_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x4581             CMP      R9,R0
   \   00000024   0xD216             BCS.N    ??hw_iic_writen_2
    274              {
    275                  for(j = 0;j < 15*40;j++); //最小延时(发送的每个字节之间要有时间间隔)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??hw_iic_writen_3
   \                     ??hw_iic_writen_4: (+1)
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??hw_iic_writen_3: (+1)
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0xF5B0 0x7F16      CMP      R0,#+600
   \   00000032   0xDBFA             BLT.N    ??hw_iic_writen_4
    276                  if (hw_iic_write1(num,DeviceAddr, AccessAddr + i, Data[i]))
   \   00000034   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000038   0xF819 0x3008      LDRB     R3,[R9, R8]
   \   0000003C   0xEB19 0x0207      ADDS     R2,R9,R7
   \   00000040   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000042   0x0031             MOVS     R1,R6
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       hw_iic_write1
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD0E1             BEQ.N    ??hw_iic_writen_1
    277                      return 1;            //其中一个字节没有发送出去,返回失败标志:1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE007             B.N      ??hw_iic_writen_5
    278              }
    279              if (i >= N)
   \                     ??hw_iic_writen_2: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000005A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005C   0x45A1             CMP      R9,R4
   \   0000005E   0xD301             BCC.N    ??hw_iic_writen_6
    280                  return 0;                //成功发送N个数据,返回成功标志:0
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE7FF             B.N      ??hw_iic_writen_5
    281          }
   \                     ??hw_iic_writen_6: (+1)
   \                     ??hw_iic_writen_5: (+1)
   \   00000064   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40066000         DC32     0x40066000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x4004C024         DC32     0x4004c024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x4004C020         DC32     0x4004c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x40066001         DC32     0x40066001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40066002         DC32     0x40066002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x4004B028         DC32     0x4004b028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x4004B02C         DC32     0x4004b02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x40067001         DC32     0x40067001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \   00000000   0x40067002         DC32     0x40067002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \   00000000   0x40067000         DC32     0x40067000
    282          
    283          #endif 

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   hw_i2c_init
      24   hw_iic_read1
        24   -> hw_send_signal
        24   -> hw_wait
      32   hw_iic_readn
        32   -> hw_iic_read1
      24   hw_iic_write1
        24   -> hw_send_signal
        24   -> hw_wait
      32   hw_iic_writen
        32   -> hw_iic_write1
       0   hw_send_signal
       4   hw_wait


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      90  hw_i2c_init
     188  hw_iic_read1
     104  hw_iic_readn
     144  hw_iic_write1
     104  hw_iic_writen
      92  hw_send_signal
      76  hw_wait

 
 842 bytes in section .text
 
 842 bytes of CODE memory

Errors: none
Warnings: 3
