###############################################################################
#                                                                             #
#                                                       28/Oct/2013  20:06:01 #
# IAR ANSI C/C++ Compiler V6.30.4.23288/W32 EVALUATION for ARM                #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\sr #
#                    c\Sources\C\Component_C\uart.c                           #
#    Command line =  "D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\s #
#                    rc\Sources\C\Component_C\uart.c" -D IAR -D TWR_K60N512   #
#                    -lCN "D:\FREESCALE智能车竞赛\freescale(九)\Photoelectric #
#                    Car\bin\Ram\List\" -lB "D:\FREESCALE智能车竞赛\freescale #
#                    (九)\PhotoelectricCar\bin\Ram\List\" -o                  #
#                    "D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\b #
#                    in\Ram\Obj\" --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config                              #
#                    E:\IAREW6.3\arm\INC\c\DLib_Config_Normal.h -I            #
#                    "D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\s #
#                    rc\Sources\H\" -I "D:\FREESCALE智能车竞赛\freescale(九)\ #
#                    PhotoelectricCar\src\Sources\H\Component_H\" -I          #
#                    "D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\s #
#                    rc\Sources\H\Frame_H\" -Ol --use_c++_inline              #
#    List file    =  D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\bi #
#                    n\Ram\List\uart.lst                                      #
#    Object file  =  D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\bi #
#                    n\Ram\Obj\uart.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\FREESCALE智能车竞赛\freescale(九)\PhotoelectricCar\src\Sources\C\Component_C\uart.c
      1          //-------------------------------------------------------------------------*
      2          // 文件名: uart.c                                                          *
      3          // 说  明: uart构件源文件                                                  *
      4          //-------------------------------------------------------------------------*
      5          
      6          #include "uart.h"
      7          extern   void delay_ms(uint32 count_val);
      8          
      9          //-------------------------------------------------------------------------*
     10          //函数名: uart_init                                                        *
     11          //功  能: 初始化uartx模块。                                                *
     12          //参  数: uartch:串口号                                                    *
     13          //        sysclk:系统总线时钟，以MHz为单位                                 *
     14          //        baud:波特率，如9600，38400等，一般来说，速度越慢，通信越稳       *
     15          //返  回: 无                                                               *
     16          //说  明:                                                                  *
     17          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     18          void uart_init (UART_MemMapPtr uartch, uint32 sysclk, uint32 baud)
     19          {
   \                     uart_init:
   \   00000000   0xB430             PUSH     {R4,R5}
     20          	register uint16 sbr, brfa;
     21          	uint8 temp;
     22          
     23          	//使能引脚
     24          	if (uartch == UART0_BASE_PTR)
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable2  ;; 0x4006a000
   \   00000006   0x4298             CMP      R0,R3
   \   00000008   0xD10A             BNE.N    ??uart_init_0
     25          	{
     26          		//在PTD6上使能UART0_TXD功能
     27          		PORTD_PCR6 = PORT_PCR_MUX(0x3);
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable2_1  ;; 0x4004c018
   \   0000000E   0xF44F 0x7440      MOV      R4,#+768
   \   00000012   0x601C             STR      R4,[R3, #+0]
     28          		//在PTD7上使能UART0_RXD
     29          		PORTD_PCR7 = PORT_PCR_MUX(0x3); 
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable2_2  ;; 0x4004c01c
   \   00000018   0xF44F 0x7440      MOV      R4,#+768
   \   0000001C   0x601C             STR      R4,[R3, #+0]
   \   0000001E   0xE049             B.N      ??uart_init_1
     30          	}else if (uartch == UART1_BASE_PTR)
   \                     ??uart_init_0:
   \   00000020   0x.... 0x....      LDR.W    R3,??DataTable2_3  ;; 0x4006b000
   \   00000024   0x4298             CMP      R0,R3
   \   00000026   0xD10A             BNE.N    ??uart_init_2
     31          	{
     32          		//在PTC4上使能UART1_TXD功能
     33          		PORTC_PCR4 = PORT_PCR_MUX(0x3); 
   \   00000028   0x.... 0x....      LDR.W    R3,??DataTable2_4  ;; 0x4004b010
   \   0000002C   0xF44F 0x7440      MOV      R4,#+768
   \   00000030   0x601C             STR      R4,[R3, #+0]
     34          		
     35          		//在PTC3上使能UART1_RXD
     36          		PORTC_PCR3 = PORT_PCR_MUX(0x3); 
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable2_5  ;; 0x4004b00c
   \   00000036   0xF44F 0x7440      MOV      R4,#+768
   \   0000003A   0x601C             STR      R4,[R3, #+0]
   \   0000003C   0xE03A             B.N      ??uart_init_1
     37          	}else if (uartch == UART2_BASE_PTR)
   \                     ??uart_init_2:
   \   0000003E   0x.... 0x....      LDR.W    R3,??DataTable2_6  ;; 0x4006c000
   \   00000042   0x4298             CMP      R0,R3
   \   00000044   0xD10A             BNE.N    ??uart_init_3
     38          	{
     39          		//在PTD3上使能UART2_TXD功能
     40          		PORTD_PCR3 = PORT_PCR_MUX(0x3); 
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable2_7  ;; 0x4004c00c
   \   0000004A   0xF44F 0x7440      MOV      R4,#+768
   \   0000004E   0x601C             STR      R4,[R3, #+0]
     41          		//在PTD2上使能UART2_RXD
     42          		PORTD_PCR2 = PORT_PCR_MUX(0x3); 
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable2_8  ;; 0x4004c008
   \   00000054   0xF44F 0x7440      MOV      R4,#+768
   \   00000058   0x601C             STR      R4,[R3, #+0]
   \   0000005A   0xE02B             B.N      ??uart_init_1
     43          	}else if (uartch == UART3_BASE_PTR)
   \                     ??uart_init_3:
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable2_9  ;; 0x4006d000
   \   00000060   0x4298             CMP      R0,R3
   \   00000062   0xD10A             BNE.N    ??uart_init_4
     44          	{
     45          		//在PTC17上使能UART3_TXD功能
     46          		PORTC_PCR17 = PORT_PCR_MUX(0x3); 
   \   00000064   0x.... 0x....      LDR.W    R3,??DataTable2_10  ;; 0x4004b044
   \   00000068   0xF44F 0x7440      MOV      R4,#+768
   \   0000006C   0x601C             STR      R4,[R3, #+0]
     47          		//在PTC16上使能UART3_RXD
     48          		PORTC_PCR16 = PORT_PCR_MUX(0x3); 
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable2_11  ;; 0x4004b040
   \   00000072   0xF44F 0x7440      MOV      R4,#+768
   \   00000076   0x601C             STR      R4,[R3, #+0]
   \   00000078   0xE01C             B.N      ??uart_init_1
     49          	}else if (uartch == UART4_BASE_PTR)
   \                     ??uart_init_4:
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable2_12  ;; 0x400ea000
   \   0000007E   0x4298             CMP      R0,R3
   \   00000080   0xD10A             BNE.N    ??uart_init_5
     50          	{
     51          		//在PTE24上使能UART4_TXD功能
     52          		PORTE_PCR24 = PORT_PCR_MUX(0x3); 
   \   00000082   0x.... 0x....      LDR.W    R3,??DataTable2_13  ;; 0x4004d060
   \   00000086   0xF44F 0x7440      MOV      R4,#+768
   \   0000008A   0x601C             STR      R4,[R3, #+0]
     53          		//在PTE25上使能UART4_RXD
     54          		PORTE_PCR25 = PORT_PCR_MUX(0x3); 
   \   0000008C   0x.... 0x....      LDR.W    R3,??DataTable2_14  ;; 0x4004d064
   \   00000090   0xF44F 0x7440      MOV      R4,#+768
   \   00000094   0x601C             STR      R4,[R3, #+0]
   \   00000096   0xE00D             B.N      ??uart_init_1
     55          	}else if (uartch == UART5_BASE_PTR)
   \                     ??uart_init_5:
   \   00000098   0x.... 0x....      LDR.W    R3,??DataTable2_15  ;; 0x400eb000
   \   0000009C   0x4298             CMP      R0,R3
   \   0000009E   0xD109             BNE.N    ??uart_init_1
     56          	{
     57          		//在PTE8上使能UART5_TXD功能
     58          		PORTE_PCR8 = PORT_PCR_MUX(0x3); 
   \   000000A0   0x.... 0x....      LDR.W    R3,??DataTable2_16  ;; 0x4004d020
   \   000000A4   0xF44F 0x7440      MOV      R4,#+768
   \   000000A8   0x601C             STR      R4,[R3, #+0]
     59          		//在PTE9上使能UART5_RXD
     60          		PORTE_PCR9 = PORT_PCR_MUX(0x3); 
   \   000000AA   0x.... 0x....      LDR.W    R3,??DataTable2_17  ;; 0x4004d024
   \   000000AE   0xF44F 0x7440      MOV      R4,#+768
   \   000000B2   0x601C             STR      R4,[R3, #+0]
     61          	}
     62          	 
     63          	//使能串口时钟    
     64          	if(uartch == UART0_BASE_PTR)
   \                     ??uart_init_1:
   \   000000B4   0x.... 0x....      LDR.W    R3,??DataTable2  ;; 0x4006a000
   \   000000B8   0x4298             CMP      R0,R3
   \   000000BA   0xD108             BNE.N    ??uart_init_6
     65          		SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable2_18  ;; 0x40048034
   \   000000C0   0x681B             LDR      R3,[R3, #+0]
   \   000000C2   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   000000C6   0x.... 0x....      LDR.W    R4,??DataTable2_18  ;; 0x40048034
   \   000000CA   0x6023             STR      R3,[R4, #+0]
   \   000000CC   0xE03B             B.N      ??uart_init_7
     66          	else
     67          		if (uartch == UART1_BASE_PTR)
   \                     ??uart_init_6:
   \   000000CE   0x.... 0x....      LDR.W    R3,??DataTable2_3  ;; 0x4006b000
   \   000000D2   0x4298             CMP      R0,R3
   \   000000D4   0xD108             BNE.N    ??uart_init_8
     68          			SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   000000D6   0x.... 0x....      LDR.W    R3,??DataTable2_18  ;; 0x40048034
   \   000000DA   0x681B             LDR      R3,[R3, #+0]
   \   000000DC   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   000000E0   0x.... 0x....      LDR.W    R4,??DataTable2_18  ;; 0x40048034
   \   000000E4   0x6023             STR      R3,[R4, #+0]
   \   000000E6   0xE02E             B.N      ??uart_init_7
     69          		else
     70          			if (uartch == UART2_BASE_PTR)
   \                     ??uart_init_8:
   \   000000E8   0x.... 0x....      LDR.W    R3,??DataTable2_6  ;; 0x4006c000
   \   000000EC   0x4298             CMP      R0,R3
   \   000000EE   0xD108             BNE.N    ??uart_init_9
     71          				SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   000000F0   0x.... 0x....      LDR.W    R3,??DataTable2_18  ;; 0x40048034
   \   000000F4   0x681B             LDR      R3,[R3, #+0]
   \   000000F6   0xF453 0x5380      ORRS     R3,R3,#0x1000
   \   000000FA   0x.... 0x....      LDR.W    R4,??DataTable2_18  ;; 0x40048034
   \   000000FE   0x6023             STR      R3,[R4, #+0]
   \   00000100   0xE021             B.N      ??uart_init_7
     72          			else
     73          				if(uartch == UART3_BASE_PTR)
   \                     ??uart_init_9:
   \   00000102   0x.... 0x....      LDR.W    R3,??DataTable2_9  ;; 0x4006d000
   \   00000106   0x4298             CMP      R0,R3
   \   00000108   0xD108             BNE.N    ??uart_init_10
     74          					SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   0000010A   0x.... 0x....      LDR.W    R3,??DataTable2_18  ;; 0x40048034
   \   0000010E   0x681B             LDR      R3,[R3, #+0]
   \   00000110   0xF453 0x5300      ORRS     R3,R3,#0x2000
   \   00000114   0x.... 0x....      LDR.W    R4,??DataTable2_18  ;; 0x40048034
   \   00000118   0x6023             STR      R3,[R4, #+0]
   \   0000011A   0xE014             B.N      ??uart_init_7
     75          				else
     76          					if(uartch == UART4_BASE_PTR)
   \                     ??uart_init_10:
   \   0000011C   0x.... 0x....      LDR.W    R3,??DataTable2_12  ;; 0x400ea000
   \   00000120   0x4298             CMP      R0,R3
   \   00000122   0xD108             BNE.N    ??uart_init_11
     77          						SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   00000124   0x.... 0x....      LDR.W    R3,??DataTable2_19  ;; 0x40048028
   \   00000128   0x681B             LDR      R3,[R3, #+0]
   \   0000012A   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   0000012E   0x.... 0x....      LDR.W    R4,??DataTable2_19  ;; 0x40048028
   \   00000132   0x6023             STR      R3,[R4, #+0]
   \   00000134   0xE007             B.N      ??uart_init_7
     78          					else
     79          						SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \                     ??uart_init_11:
   \   00000136   0x.... 0x....      LDR.W    R3,??DataTable2_19  ;; 0x40048028
   \   0000013A   0x681B             LDR      R3,[R3, #+0]
   \   0000013C   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   00000140   0x.... 0x....      LDR.W    R4,??DataTable2_19  ;; 0x40048028
   \   00000144   0x6023             STR      R3,[R4, #+0]
     80          								
     81          	//禁止发送接受
     82          	UART_C2_REG(uartch) &= ~(UART_C2_TE_MASK
     83          				| UART_C2_RE_MASK );
   \                     ??uart_init_7:
   \   00000146   0x78C3             LDRB     R3,[R0, #+3]
   \   00000148   0xF013 0x03F3      ANDS     R3,R3,#0xF3
   \   0000014C   0x70C3             STRB     R3,[R0, #+3]
     84          	
     85          	//配置成8位无校验模式
     86          	UART_C1_REG(uartch) = 0;
   \   0000014E   0x2300             MOVS     R3,#+0
   \   00000150   0x7083             STRB     R3,[R0, #+2]
     87          	
     88          	//计算波特率，串口0、1使用内核时钟，其它串口使用外设时钟，系统时钟为
     89          	//外设时钟的2倍
     90          	if ((uartch == UART0_BASE_PTR) | (uartch == UART1_BASE_PTR))//
   \   00000152   0x....             LDR.N    R3,??DataTable2  ;; 0x4006a000
   \   00000154   0x4298             CMP      R0,R3
   \   00000156   0xD008             BEQ.N    ??uart_init_12
   \   00000158   0x2300             MOVS     R3,#+0
   \   0000015A   0x....             LDR.N    R4,??DataTable2_3  ;; 0x4006b000
   \   0000015C   0x42A0             CMP      R0,R4
   \   0000015E   0xD004             BEQ.N    ??uart_init_12
   \   00000160   0xF053 0x0300      ORRS     R3,R3,#0x0
   \   00000164   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000166   0x2B00             CMP      R3,#+0
   \   00000168   0xD000             BEQ.N    ??uart_init_13
     91          		sysclk+=sysclk;
   \                     ??uart_init_12:
   \   0000016A   0x1849             ADDS     R1,R1,R1
     92          	
     93          	sbr = (uint16)((sysclk*1000)/(baud * 16));
   \                     ??uart_init_13:
   \   0000016C   0xF44F 0x737A      MOV      R3,#+1000
   \   00000170   0xFB03 0xF301      MUL      R3,R3,R1
   \   00000174   0x0114             LSLS     R4,R2,#+4
   \   00000176   0xFBB3 0xF3F4      UDIV     R3,R3,R4
     94          	temp = UART_BDH_REG(uartch) & ~(UART_BDH_SBR(0x1F));
   \   0000017A   0x7804             LDRB     R4,[R0, #+0]
   \   0000017C   0xF014 0x04E0      ANDS     R4,R4,#0xE0
     95          	UART_BDH_REG(uartch) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   00000180   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000182   0x0A1D             LSRS     R5,R3,#+8
   \   00000184   0xF015 0x051F      ANDS     R5,R5,#0x1F
   \   00000188   0x432C             ORRS     R4,R5,R4
   \   0000018A   0x7004             STRB     R4,[R0, #+0]
     96          	UART_BDL_REG(uartch) = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   0000018C   0x7043             STRB     R3,[R0, #+1]
     97          	brfa = (((sysclk*32000)/(baud * 16)) - (sbr * 32));
   \   0000018E   0xF44F 0x44FA      MOV      R4,#+32000
   \   00000192   0x4361             MULS     R1,R4,R1
   \   00000194   0x0112             LSLS     R2,R2,#+4
   \   00000196   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000019A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000019C   0xEBB1 0x1143      SUBS     R1,R1,R3, LSL #+5
     98          	temp = UART_C4_REG(uartch) & ~(UART_C4_BRFA(0x1F));
   \   000001A0   0x7A82             LDRB     R2,[R0, #+10]
   \   000001A2   0xF012 0x04E0      ANDS     R4,R2,#0xE0
     99          	UART_C4_REG(uartch) = temp |  UART_C4_BRFA(brfa);    
   \   000001A6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000001AA   0x4321             ORRS     R1,R1,R4
   \   000001AC   0x7281             STRB     R1,[R0, #+10]
    100          	
    101          	//使能发送接受
    102          	UART_C2_REG(uartch) |= (UART_C2_TE_MASK
    103          				| UART_C2_RE_MASK );
   \   000001AE   0x78C1             LDRB     R1,[R0, #+3]
   \   000001B0   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   000001B4   0x70C1             STRB     R1,[R0, #+3]
    104          }
   \   000001B6   0xBC30             POP      {R4,R5}
   \   000001B8   0x4770             BX       LR               ;; return
    105          
    106          //-------------------------------------------------------------------------*
    107          //函数名: uart_re1                                                         *
    108          //功  能: 串行接受1个字节                                                  *
    109          //参  数: uartch: 串口号                                                   *
    110          //         ch:    接收到的字节                                             *
    111          //返  回: 成功:1;失败:0                                                    *
    112          //说  明:                                                                  *
    113          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    114          uint8 uart_re1 (UART_MemMapPtr uartch,uint8 *ch)
    115          {
    116              uint32 k;
    117              
    118              for (k = 0; k < 0xfbbb; k++)//有时间限制
   \                     uart_re1:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE000             B.N      ??uart_re1_0
   \                     ??uart_re1_1:
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \                     ??uart_re1_0:
   \   00000006   0xF64F 0x33BB      MOVW     R3,#+64443
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD206             BCS.N    ??uart_re1_2
    119          		if((UART_S1_REG(uartch) & UART_S1_RDRF_MASK)!= 0)//判断接收缓冲区是否满
   \   0000000E   0x7903             LDRB     R3,[R0, #+4]
   \   00000010   0x069B             LSLS     R3,R3,#+26
   \   00000012   0xD5F7             BPL.N    ??uart_re1_1
    120          		{
    121          			*ch = UART_D_REG(uartch);
   \   00000014   0x79C0             LDRB     R0,[R0, #+7]
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    122          			return 1; 			//接受成功
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE006             B.N      ??uart_re1_3
    123          		} 
    124          	if(k>=0xfbbb) 
   \                     ??uart_re1_2:
   \   0000001C   0xF64F 0x30BB      MOVW     R0,#+64443
   \   00000020   0x4282             CMP      R2,R0
   \   00000022   0xD301             BCC.N    ??uart_re1_4
    125          	{
    126          		return 0;			//接受失败
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE000             B.N      ??uart_re1_3
    127          	} 
    128              return 0;
   \                     ??uart_re1_4:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??uart_re1_3:
   \   0000002A   0x4770             BX       LR               ;; return
    129          }
    130          
    131          //-------------------------------------------------------------------------*
    132          //函数名: uart_send1                                                       *
    133          //功  能: 串行发送1个字节                                                  *
    134          //参  数: uartch: 串口号                                                   *
    135          //         ch:    要发送的字节                                             *
    136          //返  回: 无                                                               *
    137          //说  明:                                                                  *
    138          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    139          void uart_send1 (UART_MemMapPtr uartch, uint8 ch)
    140          {
    141              //等待发送缓冲区空
    142              while(!(UART_S1_REG(uartch) & UART_S1_TDRE_MASK));
   \                     uart_send1:
   \                     ??uart_send1_0:
   \   00000000   0x7902             LDRB     R2,[R0, #+4]
   \   00000002   0x0612             LSLS     R2,R2,#+24
   \   00000004   0xD5FC             BPL.N    ??uart_send1_0
    143              //发送数据
    144              UART_D_REG(uartch) = (uint8)ch;
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    145           }
   \   00000008   0x4770             BX       LR               ;; return
    146          
    147          //-------------------------------------------------------------------------*
    148          //函数名: uart_reN                                                         *
    149          //功  能: 串行 接收n个字节                                                 *
    150          //参  数: uartch: 串口号                                                   *
    151          //        buff: 接收缓冲区                                                 *
    152          //		  len:接收长度                                             *
    153          //返  回: 1:成功;0:失败                                                    *
    154          //说  明:                                                                  *
    155          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    156          uint8 uart_reN (UART_MemMapPtr uartch ,uint8* buff,uint16 len)
    157          {
   \                     uart_reN:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    158              uint16 m=0; 
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE000             B.N      ??uart_reN_0
    159              while (m < len)
    160              { 	          
    161            	    if(0==uart_re1(uartch,&buff[m]))
    162            	    	return 0;  //接收失败
    163            	    else m++;
   \                     ??uart_reN_1:
   \   0000000C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??uart_reN_0:
   \   0000000E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000010   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000012   0x42B7             CMP      R7,R6
   \   00000014   0xD208             BCS.N    ??uart_reN_2
   \   00000016   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000018   0x1979             ADDS     R1,R7,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       uart_re1
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F3             BNE.N    ??uart_reN_1
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE000             B.N      ??uart_reN_3
    164              } 
    165              
    166              return 1;          //接收成功
   \                     ??uart_reN_2:
   \   00000028   0x2001             MOVS     R0,#+1
   \                     ??uart_reN_3:
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    167              
    168          }
    169          
    170          //-------------------------------------------------------------------------*
    171          //函数名: uart_sendN                                                       *
    172          //功  能: 串行 接收n个字节                                                 *
    173          //参  数: uartch: 串口号                                                   *
    174          //        buff: 发送缓冲区                                                 *
    175          //		  len:发送长度                                             *
    176          //返  回: 无                                                               *
    177          //说  明:                                                                  *
    178          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    179          void uart_sendN (UART_MemMapPtr uartch ,uint8* buff,uint16 len)
    180          {
   \                     uart_sendN:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    181              int i;
    182          	for(i=0;i<len;i++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE004             B.N      ??uart_sendN_0
    183              {
    184          		uart_send1(uartch,buff[i]);
   \                     ??uart_sendN_1:
   \   0000000C   0x5D79             LDRB     R1,[R7, R5]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       uart_send1
    185              }
   \   00000014   0x1C7F             ADDS     R7,R7,#+1
   \                     ??uart_sendN_0:
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x42B7             CMP      R7,R6
   \   0000001A   0xDBF7             BLT.N    ??uart_sendN_1
    186          }
   \   0000001C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    187          
    188          //-------------------------------------------------------------------------*
    189          //函数名: enableuartreint                                                  *
    190          //功  能: 开串口接收中断                                                   *
    191          //参  数: uartch: 串口号                                                   *
    192          //        irqno: 对应irq号                                                 *
    193          //返  回: 无                                                               *
    194          //说  明:                                                                  *
    195          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    196          void enableuartreint(UART_MemMapPtr uartch,uint8 irqno)
    197          {
   \                     enableuartreint:
   \   00000000   0xB580             PUSH     {R7,LR}
    198          	UART_C2_REG(uartch)|=UART_C2_RIE_MASK;   //开放UART接收中断
   \   00000002   0x78C2             LDRB     R2,[R0, #+3]
   \   00000004   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   00000008   0x70C2             STRB     R2,[R0, #+3]
    199          	enable_irq(irqno);			 //开接收引脚的IRQ中断
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x.... 0x....      BL       enable_irq
    200          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    201          
    202          //-------------------------------------------------------------------------*
    203          //函数名: disableuartreint                                                 *
    204          //功  能: 关串口接收中断                                                   *
    205          //参  数: uartch: 串口号                                                   *
    206          //        irqno: 对应irq号                                                 *
    207          //返  回: 无                                                               *
    208          //说  明:                                                                  *
    209          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    210          void disableuartreint(UART_MemMapPtr uartch,uint8 irqno)
    211          {
   \                     disableuartreint:
   \   00000000   0xB580             PUSH     {R7,LR}
    212          	UART_C2_REG(uartch)&=~UART_C2_RIE_MASK;   //禁止UART接收中断
   \   00000002   0x78C2             LDRB     R2,[R0, #+3]
   \   00000004   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   00000008   0x70C2             STRB     R2,[R0, #+3]
    213          	disable_irq(irqno);			  //关接收引脚的IRQ中断
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x.... 0x....      BL       disable_irq
    214          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    215          
    216          
    217          
    218          
    219          //-------------------------------------------------------------------------
    220          //函数名称：hw_uart_sendstring                                               
    221          //功能概要：关串口接收中断                                                   
    222          //参数说明：uartch: 串口号                                                   
    223          //           buff: 要发送的值                                                 
    224          //函数返回： 无                                                               
    225          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    226          void uart_sendstring (UART_MemMapPtr uartch ,uint8* buff)
    227          {
   \                     uart_sendstring:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    228              int i;
    229          
    230              for(i=0;buff[i] != 0;i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE004             B.N      ??uart_sendstring_0
    231              {
    232                 uart_send1(uartch,buff[i]);
   \                     ??uart_sendstring_1:
   \   0000000A   0x5D71             LDRB     R1,[R6, R5]
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       uart_send1
    233              }
   \   00000012   0x1C76             ADDS     R6,R6,#+1
   \                     ??uart_sendstring_0:
   \   00000014   0x5D70             LDRB     R0,[R6, R5]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F7             BNE.N    ??uart_sendstring_1
    234          }
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    235          //-------------------------------------------------------------------------
    236          //函数名称：hw_get_byte_array_from_number                                               
    237          //功能概要：将数组number转换成ASCII码的形式放到数组中                                                
    238          //参数说明：number: 要转换的数字                                                   
    239          //          length: 长度        
    240          //           array: 转换完的结果数组
    241          //函数返回： 无                                                               
    242          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    243          uint8 get_byte_array_from_number(uint8 array [], int * length, int number)
    244          {
   \                     get_byte_array_from_number:
   \   00000000   0xB43E             PUSH     {R1-R5}
    245              int i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    246              int j = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    247              uint8 pBuff [10];
    248              if(number < 0)
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD501             BPL.N    ??get_byte_array_from_number_0
    249              {
    250                  return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE023             B.N      ??get_byte_array_from_number_1
    251              }
    252              i = 0;
   \                     ??get_byte_array_from_number_0:
   \   0000000E   0x2300             MOVS     R3,#+0
    253              if(number == 0) //如果数字是0
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD110             BNE.N    ??get_byte_array_from_number_2
    254              {
    255                  i = 1;
   \   00000014   0x2301             MOVS     R3,#+1
    256                  *length = i;
   \   00000016   0x600B             STR      R3,[R1, #+0]
    257                  array[0] = '0';
   \   00000018   0x2130             MOVS     R1,#+48
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    258                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE01A             B.N      ??get_byte_array_from_number_1
    259              }
    260              
    261              while(number > 0)
    262              {
    263                  pBuff[i++] = number % 10;
   \                     ??get_byte_array_from_number_3:
   \   00000020   0x240A             MOVS     R4,#+10
   \   00000022   0xFB92 0xF5F4      SDIV     R5,R2,R4
   \   00000026   0xFB04 0x2415      MLS      R4,R4,R5,R2
   \   0000002A   0xAD00             ADD      R5,SP,#+0
   \   0000002C   0x555C             STRB     R4,[R3, R5]
   \   0000002E   0x1C5B             ADDS     R3,R3,#+1
    264                  number = number/10; 
   \   00000030   0x240A             MOVS     R4,#+10
   \   00000032   0xFB92 0xF2F4      SDIV     R2,R2,R4
    265              }
   \                     ??get_byte_array_from_number_2:
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xDAF2             BGE.N    ??get_byte_array_from_number_3
    266              
    267              *length = i;
   \   0000003A   0x600B             STR      R3,[R1, #+0]
    268              //将解析的ASCII码数据存放在array中
    269              for(j = 0; j < i; j++)
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0xE007             B.N      ??get_byte_array_from_number_4
    270              {
    271                  array[j] = pBuff[i - j - 1] + '0';
   \                     ??get_byte_array_from_number_5:
   \   00000040   0x1B19             SUBS     R1,R3,R4
   \   00000042   0xAA00             ADD      R2,SP,#+0
   \   00000044   0x1889             ADDS     R1,R1,R2
   \   00000046   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   0000004A   0x3130             ADDS     R1,R1,#+48
   \   0000004C   0x5421             STRB     R1,[R4, R0]
    272              }
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
   \                     ??get_byte_array_from_number_4:
   \   00000050   0x429C             CMP      R4,R3
   \   00000052   0xDBF5             BLT.N    ??get_byte_array_from_number_5
    273              //array[j] = '\0';
    274              return 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??get_byte_array_from_number_1:
   \   00000056   0xBC3E             POP      {R1-R5}
   \   00000058   0x4770             BX       LR               ;; return
    275          }
    276          
    277          
    278          //-------------------------------------------------------------------------
    279          //函数名称：hw_uart_sendnumber                                               
    280          //功能概要：将数字转换成字符串发送出去  如123转换成"123"发送出去                                                
    281          //参数说明：uartch: 串口号                                                   
    282          //           buff: 要发送的值                                                 
    283          //函数返回： 无                                                               
    284          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    285          uint8 uart_sendnumber(UART_MemMapPtr uartch , uint8 number)
    286          {
   \                     uart_sendnumber:
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    287              uint8 array[10];
    288              int len = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    289              if(get_byte_array_from_number(array, &len, number) == 0)
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x000A             MOVS     R2,R1
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       get_byte_array_from_number
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE.N    ??uart_sendnumber_0
    290              {
    291              	uart_sendN(uartch, (uint8*)array, len);
   \   00000018   0x9A00             LDR      R2,[SP, #+0]
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       uart_sendN
    292              }
    293              else
    294              {
    295                  return 0;
    296              } 
    297              return 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??uart_sendnumber_1
   \                     ??uart_sendnumber_0:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??uart_sendnumber_1:
   \   0000002A   0xB004             ADD      SP,SP,#+16
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    298          }
    299          

   \                                 In section .text, align 2, keep-with-next
    300          void uart3_send ( char ch)
    301          {
    302              //等待发送缓冲区空
    303              while(!(UART_S1_REG(UART3) & UART_S1_TDRE_MASK));
   \                     uart3_send:
   \                     ??uart3_send_0:
   \   00000000   0x....             LDR.N    R1,??DataTable2_20  ;; 0x4006d004
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0609             LSLS     R1,R1,#+24
   \   00000006   0xD5FB             BPL.N    ??uart3_send_0
    304              //发送数据
    305              UART_D_REG(UART3) = (uint8)ch;
   \   00000008   0x....             LDR.N    R1,??DataTable2_21  ;; 0x4006d007
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    306          }
   \   0000000C   0x4770             BX       LR               ;; return
    307          
    308          //针对MiniIMU AHRS软件的参数串口波形测试

   \                                 In section .text, align 2, keep-with-next
    309          void Uart_Test(uint16 ax,uint16 ay,uint16 az,uint16 gx,uint16 gy,uint16 gz,
    310          					uint16 hx,uint16 hy,uint16 hz)
    311          {
   \                     Uart_Test:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x4699             MOV      R9,R3
   \   00000006   0x9C0C             LDR      R4,[SP, #+48]
   \   00000008   0x9D0D             LDR      R5,[SP, #+52]
   \   0000000A   0x9E0E             LDR      R6,[SP, #+56]
   \   0000000C   0x9F0F             LDR      R7,[SP, #+60]
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    312           	unsigned int temp=0xaF+9;
   \   00000012   0xF05F 0x0AB8      MOVS     R10,#+184
    313          	char ctemp;
    314          	uart3_send(0xa5);
   \   00000016   0x20A5             MOVS     R0,#+165
   \   00000018   0x.... 0x....      BL       uart3_send
    315          	uart3_send(0x5a);
   \   0000001C   0x205A             MOVS     R0,#+90
   \   0000001E   0x.... 0x....      BL       uart3_send
    316          	uart3_send(14+8);
   \   00000022   0x2016             MOVS     R0,#+22
   \   00000024   0x.... 0x....      BL       uart3_send
    317          	uart3_send(0xA2);
   \   00000028   0x20A2             MOVS     R0,#+162
   \   0000002A   0x.... 0x....      BL       uart3_send
    318                  
    319          	ctemp=ax>>8;
   \   0000002E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0xEA5F 0x2B10      LSRS     R11,R0,#+8
    320          	uart3_send(ctemp);
   \   00000038   0x4658             MOV      R0,R11
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       uart3_send
    321          	temp+=ctemp;
   \   00000040   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    322          	ctemp=ax;
   \   00000044   0xF8BD 0xB000      LDRH     R11,[SP, #+0]
    323          	uart3_send(ctemp);
   \   00000048   0x4658             MOV      R0,R11
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x.... 0x....      BL       uart3_send
    324          	temp+=ctemp;
   \   00000050   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    325          
    326          	ctemp=ay>>8;
   \   00000054   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0xEA5F 0x2B10      LSRS     R11,R0,#+8
    327          	uart3_send(ctemp);
   \   0000005E   0x4658             MOV      R0,R11
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       uart3_send
    328          	temp+=ctemp;
   \   00000066   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    329          	ctemp=ay;
   \   0000006A   0xF8BD 0xB004      LDRH     R11,[SP, #+4]
    330          	uart3_send(ctemp);
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       uart3_send
    331          	temp+=ctemp;
   \   00000076   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    332                  
    333          	ctemp=az>>8;
   \   0000007A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000007E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000080   0xEA5F 0x2B10      LSRS     R11,R0,#+8
    334          	uart3_send(ctemp);
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x.... 0x....      BL       uart3_send
    335          	temp+=ctemp;
   \   0000008C   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    336          	ctemp=az;
   \   00000090   0xF8BD 0xB008      LDRH     R11,[SP, #+8]
    337          	uart3_send(ctemp);
   \   00000094   0x4658             MOV      R0,R11
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x.... 0x....      BL       uart3_send
    338          	temp+=ctemp;
   \   0000009C   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    339          
    340          	ctemp=gx>>8;
   \   000000A0   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   000000A4   0xEA5F 0x2B19      LSRS     R11,R9,#+8
    341          	uart3_send(ctemp);
   \   000000A8   0x4658             MOV      R0,R11
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x.... 0x....      BL       uart3_send
    342          	temp+=ctemp;
   \   000000B0   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    343          	ctemp=gx;
   \   000000B4   0x46CB             MOV      R11,R9
    344          	uart3_send(ctemp);
   \   000000B6   0x4658             MOV      R0,R11
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x.... 0x....      BL       uart3_send
    345          	temp+=ctemp;
   \   000000BE   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    346          //-----------------------------
    347          	ctemp=gy>>8;
   \   000000C2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000C4   0xEA5F 0x2B14      LSRS     R11,R4,#+8
    348          	uart3_send(ctemp);
   \   000000C8   0x4658             MOV      R0,R11
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x.... 0x....      BL       uart3_send
    349          	temp+=ctemp;
   \   000000D0   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    350          	ctemp=gy;
   \   000000D4   0x46A3             MOV      R11,R4
    351          	uart3_send(ctemp);
   \   000000D6   0x4658             MOV      R0,R11
   \   000000D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DA   0x.... 0x....      BL       uart3_send
    352          	temp+=ctemp;
   \   000000DE   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    353                  
    354          	ctemp=gz>>8;
   \   000000E2   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000E4   0xEA5F 0x2B15      LSRS     R11,R5,#+8
    355          	uart3_send(ctemp);
   \   000000E8   0x4658             MOV      R0,R11
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0x.... 0x....      BL       uart3_send
    356          	temp+=ctemp;
   \   000000F0   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    357          	ctemp=gz;
   \   000000F4   0x46AB             MOV      R11,R5
    358          	uart3_send(ctemp);
   \   000000F6   0x4658             MOV      R0,R11
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       uart3_send
    359          	temp+=ctemp;
   \   000000FE   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    360          //--------------------------
    361                  
    362          	ctemp=hx>>8;
   \   00000102   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000104   0xEA5F 0x2B16      LSRS     R11,R6,#+8
    363          	uart3_send(ctemp);
   \   00000108   0x4658             MOV      R0,R11
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x.... 0x....      BL       uart3_send
    364          	temp+=ctemp;
   \   00000110   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    365          	ctemp=hx;
   \   00000114   0x46B3             MOV      R11,R6
    366          	uart3_send(ctemp);
   \   00000116   0x4658             MOV      R0,R11
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0x.... 0x....      BL       uart3_send
    367          	temp+=ctemp;
   \   0000011E   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    368                  
    369          	ctemp=hy>>8;
   \   00000122   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000124   0xEA5F 0x2B17      LSRS     R11,R7,#+8
    370          	uart3_send(ctemp);
   \   00000128   0x4658             MOV      R0,R11
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012C   0x.... 0x....      BL       uart3_send
    371          	temp+=ctemp;
   \   00000130   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    372          	ctemp=hy;
   \   00000134   0x46BB             MOV      R11,R7
    373          	uart3_send(ctemp);
   \   00000136   0x4658             MOV      R0,R11
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0x.... 0x....      BL       uart3_send
    374          	temp+=ctemp;
   \   0000013E   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    375          
    376          	ctemp=hz>>8;
   \   00000142   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000146   0xEA5F 0x2B18      LSRS     R11,R8,#+8
    377          	uart3_send(ctemp);
   \   0000014A   0x4658             MOV      R0,R11
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x.... 0x....      BL       uart3_send
    378          	temp+=ctemp;
   \   00000152   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    379          	ctemp=hz;
   \   00000156   0x46C3             MOV      R11,R8
    380          	uart3_send(ctemp);
   \   00000158   0x4658             MOV      R0,R11
   \   0000015A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015C   0x.... 0x....      BL       uart3_send
    381          	temp+=ctemp;
   \   00000160   0xFA5A 0xFA8B      UXTAB    R10,R10,R11
    382          
    383          	uart3_send(temp%256);
   \   00000164   0xF44F 0x7180      MOV      R1,#+256
   \   00000168   0xFBBA 0xF0F1      UDIV     R0,R10,R1
   \   0000016C   0xFB00 0xA011      MLS      R0,R0,R1,R10
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x.... 0x....      BL       uart3_send
    384          	uart3_send(0xaa);
   \   00000176   0x20AA             MOVS     R0,#+170
   \   00000178   0x.... 0x....      BL       uart3_send
    385          }
   \   0000017C   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    386          //串口发送数据

   \                                 In section .text, align 2, keep-with-next
    387          void serial_choose()
    388          {
   \                     serial_choose:
   \   00000000   0xB580             PUSH     {R7,LR}
    389          
    390              //帧头数据
    391              uart_send1 (UART3, 0xa5);
   \   00000002   0x21A5             MOVS     R1,#+165
   \   00000004   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   00000006   0x.... 0x....      BL       uart_send1
    392          
    393              uart_send1 (UART3, 0x5a);
   \   0000000A   0x215A             MOVS     R1,#+90
   \   0000000C   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   0000000E   0x.... 0x....      BL       uart_send1
    394          
    395          	//选择的线条
    396          	//此处选择了第一,二,三条线
    397          
    398              uart_send1 (UART3, 0x01);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   00000016   0x.... 0x....      BL       uart_send1
    399              uart_send1 (UART3, 0x01);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   0000001E   0x.... 0x....      BL       uart_send1
    400              uart_send1 (UART3, 0x01);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   00000026   0x.... 0x....      BL       uart_send1
    401              uart_send1 (UART3, 0x00);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   0000002E   0x.... 0x....      BL       uart_send1
    402              uart_send1 (UART3, 0x00);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x....             LDR.N    R0,??DataTable2_9  ;; 0x4006d000
   \   00000036   0x.... 0x....      BL       uart_send1
    403              delay_ms(10);
   \   0000003A   0x200A             MOVS     R0,#+10
   \   0000003C   0x.... 0x....      BL       delay_ms
    404          }
   \   00000040   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x4004C018         DC32     0x4004c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4004C01C         DC32     0x4004c01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_17:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_18:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_19:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_20:
   \   00000000   0x4006D004         DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_21:
   \   00000000   0x4006D007         DC32     0x4006d007
    405          
    406          
    407          
    408          
    409          
    410          
    411          
    412          
    413          
    414          
    415          
    416          
    417          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       48  Uart_Test
             48 -> uart3_send
        8  disableuartreint
              8 -> disable_irq
        8  enableuartreint
              8 -> enable_irq
       20  get_byte_array_from_number
        8  serial_choose
              8 -> delay_ms
              8 -> uart_send1
        0  uart3_send
        8  uart_init
        0  uart_re1
       24  uart_reN
             24 -> uart_re1
        0  uart_send1
       24  uart_sendN
             24 -> uart_send1
       24  uart_sendnumber
             24 -> get_byte_array_from_number
             24 -> uart_sendN
       16  uart_sendstring
             16 -> uart_send1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_18
       4  ??DataTable2_19
       4  ??DataTable2_2
       4  ??DataTable2_20
       4  ??DataTable2_21
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     384  Uart_Test
      20  disableuartreint
      20  enableuartreint
      90  get_byte_array_from_number
      66  serial_choose
      14  uart3_send
     442  uart_init
      44  uart_re1
      44  uart_reN
      10  uart_send1
      30  uart_sendN
      46  uart_sendnumber
      28  uart_sendstring

 
 1 326 bytes in section .text
 
 1 326 bytes of CODE memory

Errors: none
Warnings: none
